.include "macrolib.asm"	

.data
n:	.word	0		# Число введенных элементов массива
error:  .asciz  "incorrect n!\n"  # Сообщение о некорректном вводе
sep:    .asciz  "\n"    # Строка-разделитель (с \n и нулём в конце)
printNewArr: .asciz "New array: "
printOldArr: .asciz "Old array: "
array:  .space  40             # выделяем 40 байт
prompt: .asciz  "n = "         # Подсказка для ввода числа
arrsep: .asciz  " "	# separator

.text
.globl main
main:
	# Передаем адрес элемента a0, 
	# в который будем записывать считываемое значение
	fillel (a0)             # Считываем n
	mv      t3 a0           # Сохраняем результат в t3 (это n)
        ble     t3 zero fail    # На ошибку, если меньше 1
        li      t4 10           # Размер массива
        bgt     t3 t4 fail      # На ошибку, если больше 10
        
        la	t4 n		# Адрес n в t4
        sw	t3 (t4)		# Загрузка n в память на хранение
        
        la      t0 array        # Указатель первого элемента массива
        
       	jal fillArr # Заполняем массив
       	
       	lw	t3 n		# Число элементов массива
        la	t0 array
       	
       	la      a0 printOldArr
        li      a7 4
        ecall
        
        jal printArr		# Выводим массив A
       	
        lw	t3 n		# Число элементов массива
        la	t0 array
	
	jal createNewArr	# Создаем массив B на основе A
	
	
	lw	t3 n		# Число элементов массива
        la	t0 array
        
        
        la      a0 printNewArr          
        li      a7 4
        ecall
        
        jal printArr		# Выводим массив B 

        li      a7 10           # Останов
        ecall
	
	
# Заполняем массив, считывая элементы с клавиатуры
fillArr:
	# В t0 лежит начало массива
	# В t3 лежит n - кол-во элементов в массиве
        fillel (t2)		# Считываем элемент с помощью макроса
        
	sw      t2 (t0)         # Запись числа по адресу в t0
        addi    t0 t0 4         # Увеличим адрес на размер слова в байтах
        addi    t3 t3 -1        # Уменьшим количество оставшихся элементов на 1
        bnez    t3 fillArr         # Если осталось больше 0
        la      a0 sep          # Выведем строку-разделитель
        li      a7 4
        ecall
        ret
      
# Выводим массив
printArr:
	# В t0 лежит начало массива
	# В t3 лежит n - кол-во элементов в массиве
	lw a0 (t0)         # Запись числа по адресу в t0
	
	printel (a0)       # Выводим элемент, используя макрос
		
	la a0, arrsep		
	li a7, 4
   	ecall
	
        addi    t0 t0 4         # Увеличим адрес на размер слова в байтах
        
        
        addi    t3 t3 -1        # Уменьшим количество оставшихся элементов на 1
        bnez    t3 printArr         # Если осталось больше 0
        
        
        la      a0 sep          # Выведем строку-разделитель
        li      a7 4
        ecall
        ret


# Создание новый массив, на основе предыдущего
createNewArr:
	# В t0 лежит начало массива
	# В t3 лежит n - кол-во элементов в массиве
	lw      a0 (t0)         # Запись числа по адресу в t0
	li t5, 5
	
	bgt a0,t5, more5	# Проверка условия, что x>5
	li t5, -5
	blt a0,t5, less5	# Проверка условия, что x<-5
	li a0, 0
	sw a0 (t0)
	
	cont:
	
        addi    t0 t0 4         # Увеличим адрес на размер слова в байтах
        
        
        addi    t3 t3 -1        # Уменьшим количество оставшихся элементов на 1
        bnez    t3 createNewArr         # Если осталось больше 0
        
        
        la      a0 sep          # Выведем строку-разделитель
        li      a7 4
        ecall
        ret
        
        
more5:		# Прибавляем 5 к элементу, если он >5
	addi a0,a0,5
	sw a0 (t0)
	j cont
	
	
less5:		# Отнимаем 5 от элемента, если он <-5
	addi a0,a0,-5
	sw a0 (t0)
	j cont
	
  
# Если введено некорректное значение n
fail:
        la 	a0, error       # Сообщение об ошибке ввода числа элементов массива
        li 	a7, 4           # Системный вызов №4
        ecall
        li      a7 10           # Останов
        ecall

        
        

	
	
